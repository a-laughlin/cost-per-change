// state format
// const globalStateHOC = withGlobalState({initialState:{
//   userTokens:{
//     '0':{id:'0',value:'49c740018d76ccec3621177873e29905dc427e7b'}
//   },// value:'<token here>', },
//   repos:{
//     'repo0':{id:'repo0', repoid:'repo0', url:`https://github.com/a-laughlin/nametbd/prev-version`,'changetime':'60',devcost:'80'},
//   },
//   repoNodes:{
//     'repo0_f0':{id:'repo0_f0',repoid:'repo0',path:`/src/apps`,enabled:true,hovered:false},
//     'repo0_f1':{id:'repo0_f1',repoid:'repo0',path:`/src/apps/chrome.js`, code:'const example={foo:"bar"};',enabled:true,hovered:false},
//     'repo0_f2':{id:'repo0_f2',repoid:'repo0',path:`/src/apps/firefox.js`,code:'const example=(a,b)=>({foo:a,baz:b});',enabled:true,hovered:false},
//   },
//   repoNodeOutEdges:{
//     repo0_f0:{id:'repo0_f0',repoid:'repo0',edges:['repo0_f1','repo0_f2']},
//   },
//   helpMessages:{
//     // '0':{id:'0',msg:'hello world'},
//   },
// }});

/*eslint-disable*/
export const initialState = {"userTokens":{"0":{"id":"0","value":""}},"repos":{"repo0":{"id":"repo0","repoid":"repo0","url":"https://github.com/a-laughlin/escomplex/tree/master/src","changetime":"60","devcost":"80","maintainabilityMin":108.47565604771552,"maintainabilityMax":141.42876602520218,"cyclomaticMin":1,"cyclomaticMax":6,"effortMin":111.01319154423277,"effortMax":3656.5104891078227,"locMin":2,"locMax":8.333333333333334,"paramsMin":0,"paramsMax":2.5,"costPerChangeMax":300.1168509709655,"costPerChangeMin":141.94192307902955}},"repoNodes":{"repo0_root":{"name":"src","path":"src","repoid":"repo0","enabled":true,"hovered":false,"id":"repo0_root"},"repo0src/config_js":{"id":"repo0src/config_js","name":"config.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/config.js","code":"'use strict'\n\nmodule.exports.parserOptions = {\n  ecmaVersion: 8,\n  loc: true\n}\n"},"repo0src/core_js":{"id":"repo0src/core_js","name":"core.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/core.js","code":"'use strict'\n\nconst projectHandler = require('./project')\nconst moduleHandler = require('./module')\n\nmodule.exports.analyse = analyse\nmodule.exports.processResults = processResults\n\n/**\n * Public function `analyse`.\n *\n * Returns an object detailing the complexity of abstract syntax tree(s).\n *\n * @param ast {object|array}  The abstract syntax tree(s) to analyse for\n *                            code complexity.\n * @param walker {object}     The AST walker to use against `ast`.\n * @param [options] {object}  Options to modify the complexity calculation.\n *\n */\n\nfunction analyse (ast, walker, options) {\n  if (Array.isArray(ast)) {\n    return projectHandler.analyse(ast, walker, options)\n  }\n  return moduleHandler.analyse(ast, walker, options)\n}\n\n/**\n * Public function `processResults`.\n *\n * Given an object with an array of results, it returns results with calculated aggregate values.\n *\n * @param report {object}  The report object with an array of results for calculating aggregates.\n * @param noCoreSize {boolean} Don't compute coresize or the visibility matrix.\n *\n */\n\nfunction processResults (report, noCoreSize) {\n  return projectHandler.processResults(report, noCoreSize)\n}\n"},"repo0src/index_js":{"id":"repo0src/index_js","name":"index.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/index.js","code":"'use strict'\n\nconst _assign = require('lodash.assign')\nconst _negate = require('lodash.negate')\nconst _isNil = require('lodash.isnil')\nconst espree = require('espree')\nconst walker = require('./walker')\nconst core = require('./core')\nconst defaultParserOptions = require('./config').parserOptions\n\nmodule.exports.analyse = function(source, options, parsing){\n  if (Array.isArray(source)) {\n    return analyseProject(source, options, parsing)\n  }\n  return analyseModule(source, options, parsing)\n}\n\nmodule.exports.analyseModule = analyseModule\nmodule.exports.analyseProject = analyseProject\n\nfunction analyseProject (source, options, parsing) {\n  const parser = getParser(parsing)\n  const parserOptions = getParserOptions(parsing)\n  const ast = parseProject(source, parser, parserOptions, options)\n  return core.analyse(ast, walker, options)\n}\n\nfunction analyseModule (source, options, parsing) {\n  const parser = getParser(parsing)\n  const parserOptions = getParserOptions(parsing)\n  const ast = parser(source, parserOptions)\n  return core.analyse(ast, walker, options)\n}\n\nfunction getParserOptions (options) {\n  const results = defaultParserOptions\n  if (typeof options === 'object') {\n    _assign(results, options)\n  }\n\n  // We must enable locations for the\n  // Resulting AST, otherwise the metrics\n  // Will be missing line information.\n  results.loc = true\n  return results\n}\n\nfunction getParser (customParser) {\n  if (typeof customParser === 'function') {\n    return customParser\n  }\n  return defaultParser\n}\n\nfunction defaultParser (source, parserOptions) {\n  return espree.parse(source, parserOptions)\n}\n\nfunction parseProject (sources, parser, parserOptions, options) {\n  return sources.map(function(source){\n    try {\n      return {\n        ast: parser(source.code, parserOptions),\n        path: source.path\n      }\n    } catch (error) {\n      if (options.ignoreErrors) {\n        return null\n      }\n      error.message = source.path + ': ' + error.message\n      throw error\n    }\n  })\n  .filter(_negate(_isNil))\n}\n"},"repo0src/module_js":{"id":"repo0src/module_js","name":"module.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/module.js","code":"'use strict'\n\nconst _isObject = require('lodash.isobject')\nconst _isFunction = require('lodash.isfunction')\nconst _isNumber = require('lodash.isnumber')\nconst assert = require('assert')\nconst debug = require('debug')('escomplex:module')\nconst HalsteadMetrics = require('./metrics/halstead')\nconst defaultSettings = {\n  forin: false,\n  logicalor: true,\n  newmi: false,\n  switchcase: true,\n  trycatch: false\n}\n\n\n\nvar report\n\nmodule.exports.analyse = function analyse (ast, walker, options) {\n  // TODO: Asynchronise\n  var settings\n  var currentReport\n  var clearDependencies = true\n  const scopeStack = []\n\n  assert(_isObject(ast), 'Invalid syntax tree')\n  assert(_isObject(walker), 'Invalid walker')\n  assert(_isFunction(walker.walk), 'Invalid walker.walk method')\n\n  settings = _isObject(options) ? options : defaultSettings\n\n  // TODO: loc is moz-specific, move to walker?\n  report = createReport(ast.loc)\n  debug('Walking the AST:')\n  debug(JSON.stringify(ast, null, 2))\n  walker.walk(ast, settings, {\n    createScope: pushScope,\n    popScope: popScope,\n    processNode: processNode\n  })\n  calculateMetrics(settings)\n\n  function processNode (node, syntax) {\n    processLloc(node, syntax, currentReport)\n    processCyclomatic(node, syntax, currentReport)\n    processOperators(node, syntax, currentReport)\n    processOperands(node, syntax, currentReport)\n    if (processDependencies(node, syntax, clearDependencies)) {\n      // HACK: This will fail with async or if other syntax than CallExpression introduces dependencies.\n      // TODO: Come up with a less crude approach.\n      clearDependencies = false\n    }\n  }\n\n  function pushScope (name, loc, parameterCount) {\n    currentReport = createFunctionReport(name, loc, parameterCount)\n    report.functions.push(currentReport)\n    report.aggregate.params += parameterCount\n    scopeStack.push(currentReport)\n  }\n\n  function popScope () {\n    scopeStack.pop()\n    if (scopeStack.length > 0) {\n      currentReport = scopeStack[scopeStack.length - 1]\n    } else {\n      currentReport = undefined\n    }\n  }\n\n  return report\n}\n\nfunction createReport (lines) {\n  return {\n    aggregate: createFunctionReport(undefined, lines, 0),\n    dependencies: [],\n    functions: []\n  }\n}\n\nfunction createFunctionReport (name, lines, params) {\n  const result = {\n    cyclomatic: 1,\n    halstead: new HalsteadMetrics(),\n    name: name,\n    params: params,\n    sloc: {\n      logical: 0\n    }\n  }\n  if (_isObject(lines)) {\n    debug('Calculating line information...')\n    debug('start line: ' + lines.start.line)\n    debug('end line: ' + lines.end.line)\n    result.line = lines.start.line\n    result.sloc.physical = lines.end.line - lines.start.line + 1\n    debug('physical lines: ' + result.sloc.physical)\n  }\n  return result\n}\n\nfunction processLloc (node, syntax, currentReport) {\n  incrementCounter(node, syntax, 'lloc', incrementLogicalSloc, currentReport)\n}\n\nfunction incrementCounter (node, syntax, name, incrementFn, currentReport) {\n  const amount = syntax[name]\n  if (_isNumber(amount)) {\n    incrementFn(currentReport, amount)\n  } else if (_isFunction(amount)) {\n    incrementFn(currentReport, amount(node))\n  }\n}\n\nfunction incrementLogicalSloc (currentReport, amount) {\n  debug('incrementing sloc by ' + amount)\n  report.aggregate.sloc.logical += amount\n  if (currentReport) {\n    currentReport.sloc.logical += amount\n  }\n}\n\nfunction processCyclomatic (node, syntax, currentReport) {\n  incrementCounter(node, syntax, 'cyclomatic', incrementCyclomatic, currentReport)\n}\n\nfunction incrementCyclomatic (currentReport, amount) {\n  report.aggregate.cyclomatic += amount\n  if (currentReport) {\n    currentReport.cyclomatic += amount\n  }\n}\n\nfunction processOperators (node, syntax, currentReport) {\n  processHalsteadMetric(node, syntax, 'operators', currentReport)\n}\n\nfunction processOperands (node, syntax, currentReport) {\n  processHalsteadMetric(node, syntax, 'operands', currentReport)\n}\n\nfunction processHalsteadMetric (node, syntax, metric, currentReport) {\n  if (Array.isArray(syntax[metric])) {\n    syntax[metric].forEach(function(s){\n      var identifier\n      if (_isFunction(s.identifier)) {\n        identifier = s.identifier(node)\n      } else {\n        identifier = s.identifier\n      }\n      if (_isFunction(s.filter) === false || s.filter(node) === true) {\n        halsteadItemEncountered(currentReport, metric, identifier)\n      }\n    })\n  }\n}\n\nfunction halsteadItemEncountered (currentReport, metric, identifier) {\n  if (currentReport) {\n    incrementHalsteadItems(currentReport, metric, identifier)\n  }\n  incrementHalsteadItems(report.aggregate, metric, identifier)\n}\n\nfunction incrementHalsteadItems (baseReport, metric, identifier) {\n  incrementDistinctHalsteadItems(baseReport, metric, identifier)\n  incrementTotalHalsteadItems(baseReport, metric)\n}\n\nfunction incrementDistinctHalsteadItems (baseReport, metric, identifier) {\n  if (Object.prototype.hasOwnProperty(identifier)) {\n    // Avoid clashes with built-in property names.\n    incrementDistinctHalsteadItems(baseReport, metric, '_' + identifier)\n  } else {\n    if (isHalsteadMetricDistinct(baseReport, metric, identifier)) {\n      recordDistinctHalsteadMetric(baseReport, metric, identifier)\n      incrementHalsteadMetric(baseReport, metric, 'distinct')\n    }\n  }\n}\n\nfunction isHalsteadMetricDistinct (baseReport, metric, identifier) {\n  return baseReport.halstead[metric].identifiers.indexOf(identifier) === -1\n}\n\nfunction recordDistinctHalsteadMetric (baseReport, metric, identifier) {\n  baseReport.halstead[metric].identifiers.push(identifier)\n}\n\nfunction incrementHalsteadMetric (baseReport, metric, type) {\n  if (baseReport) {\n    baseReport.halstead[metric][type] += 1\n  }\n}\n\nfunction incrementTotalHalsteadItems (baseReport, metric) {\n  incrementHalsteadMetric(baseReport, metric, 'total')\n}\n\nfunction processDependencies (node, syntax, clearDependencies) {\n  var dependencies\n  if (_isFunction(syntax.dependencies)) {\n    dependencies = syntax.dependencies(node, clearDependencies)\n    if (_isObject(dependencies) || Array.isArray(dependencies)) {\n      report.dependencies = report.dependencies.concat(dependencies)\n    }\n    return true\n  }\n  return false\n}\n\nfunction calculateMetrics (settings) {\n  var count\n  var indices\n  var sums\n  var averages\n  count = report.functions.length\n  indices = {\n    cyclomatic: 1,\n    effort: 2,\n    loc: 0,\n    params: 3\n  }\n  sums = [\n    0,\n    0,\n    0,\n    0\n  ]\n  report.functions.forEach(function(functionReport){\n    calculateCyclomaticDensity(functionReport)\n    functionReport.halstead.calculate()\n    sumMaintainabilityMetrics(sums, indices, functionReport)\n  })\n  calculateCyclomaticDensity(report.aggregate)\n  report.aggregate.halstead.calculate()\n  if (count === 0) {\n    // Sane handling of modules that contain no functions.\n    sumMaintainabilityMetrics(sums, indices, report.aggregate)\n    count = 1\n  }\n  averages = sums.map(function(sum){return sum/count;})\n  report.maintainability = calculateMaintainabilityIndex(\n    averages[indices.effort],\n    averages[indices.cyclomatic],\n    averages[indices.loc],\n    settings.newmi\n  )\n  Object.keys(indices).forEach(function(index){\n    report[index] = averages[indices[index]]\n  })\n}\n\nfunction calculateCyclomaticDensity (data) {\n  data.cyclomaticDensity = (data.cyclomatic / data.sloc.logical) * 100\n}\n\nfunction sumMaintainabilityMetrics (sums, indices, data) {\n  sums[indices.loc] += data.sloc.logical\n  sums[indices.cyclomatic] += data.cyclomatic\n  sums[indices.effort] += data.halstead.effort\n  sums[indices.params] += data.params\n}\n\nfunction calculateMaintainabilityIndex (averageEffort, averageCyclomatic, averageLoc, newmi) {\n  if (averageCyclomatic === 0) {\n    throw new Error('Encountered function with cyclomatic complexity zero!')\n  }\n  var maintainability = 171 - (3.42 * Math.log(averageEffort)) - (0.23 * Math.log(averageCyclomatic)) - (16.2 * Math.log(averageLoc))\n  if (maintainability > 171) {\n    maintainability = 171\n  }\n  if (newmi) {\n    maintainability = Math.max(0, (maintainability * 100) / 171)\n  }\n  return maintainability\n}\n"},"repo0src/project_js":{"id":"repo0src/project_js","name":"project.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/project.js","code":"'use strict';\n\nvar _isString = require('lodash.isstring');\nvar assert = require('assert');\nvar path = require('path');\nvar moduleAnalyser = require('./module');\n\nexports.analyse = analyse;\nexports.processResults = processResults;\n\nfunction analyse(modules, walker, options) {\n  // TODO: Asynchronize.\n  options = options || {};\n  assert(Array.isArray(modules), 'Invalid modules');\n\n  var reports = modules.map(function (m) {\n    var report;\n    assert(_isString(m.path) && m.path.length > 0, 'Invalid path');\n    try {\n      report = moduleAnalyser.analyse(m.ast, walker, options);\n      report.path = m.path;\n      return report;\n    } catch (error) {\n      // These error messages are useless unless they contain the module path.\n      error.message = m.path + ': ' + error.message;\n      throw error;\n    }\n  }, []);\n  if (options.skipCalculation) {\n    return { reports: reports };\n  }\n  return processResults({ reports: reports }, options.noCoreSize);\n}\n\nfunction processResults(result, noCoreSize) {\n  createAdjacencyMatrix(result);\n  if (!noCoreSize) {\n    createVisibilityMatrix(result);\n    setCoreSize(result);\n  }\n  calculateAverages(result);\n  return result;\n}\n\nfunction createAdjacencyMatrix(result) {\n  var adjacencyMatrix = new Array(result.reports.length);\n  var density = 0;\n  result.reports.sort(function (lhs, rhs) {\n    return comparePaths(lhs.path, rhs.path);\n  }).forEach(function (ignore, x) {\n    adjacencyMatrix[x] = new Array(result.reports.length);\n    result.reports.forEach(function (ignore, y) {\n      adjacencyMatrix[x][y] = getAdjacencyMatrixValue(result.reports, x, y);\n      if (adjacencyMatrix[x][y] === 1) {\n        density += 1;\n      }\n    });\n  });\n  result.adjacencyMatrix = adjacencyMatrix;\n  result.firstOrderDensity = percentifyDensity(density, adjacencyMatrix);\n}\n\nfunction comparePaths(lhs, rhs) {\n  var lsplit = lhs.split(path.sep);\n  var rsplit = rhs.split(path.sep);\n  if (lsplit.length < rsplit.length || lsplit.length === rsplit.length && lhs < rhs) {\n    return -1;\n  }\n  if (lsplit.length > rsplit.length || lsplit.length === rsplit.length && lhs > rhs) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction getAdjacencyMatrixValue(reports, x, y) {\n  if (x === y) {\n    return 0;\n  }\n  if (doesDependencyExist(reports[x], reports[y])) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction doesDependencyExist(from, to) {\n  return from.dependencies.reduce(function (result, dependency) {\n    if (result === false) {\n      return checkDependency(from.path, dependency, to.path);\n    }\n    return true;\n  }, false);\n}\n\nfunction checkDependency(from, dependency, to) {\n  if (isCommonJSDependency(dependency)) {\n    if (isInternalCommonJSDependency(dependency)) {\n      return isDependency(from, dependency, to);\n    }\n    return false;\n  }\n  return isDependency(from, dependency, to);\n}\n\nvar percentify = function percentify(value, limit) {\n  return limit === 0 ? 0 : value / limit * 100;\n};\nvar percentifyDensity = function percentifyDensity(density, matrix) {\n  return percentify(density, matrix.length * matrix.length);\n};\n\nvar isCommonJSDependency = function isCommonJSDependency(dependency) {\n  return dependency.type === 'CommonJS';\n};\nvar isInternalCommonJSDependency = function isInternalCommonJSDependency(dependency) {\n  return dependency.path[0] === '.' && (dependency.path[1] === path.sep || dependency.path[1] === '.' && dependency.path[2] === path.sep);\n};\n\nfunction isDependency(from, dependency, to) {\n  var dependencyPath = dependency.path;\n  var fromFileAbsolutePath = path.resolve(from);\n  var toFileAbsolutePath = path.resolve(to);\n  var dependencyAbsolutePath = path.resolve(path.dirname(fromFileAbsolutePath), dependencyPath);\n  if (path.extname(dependencyPath) === '') {\n    var index = path.join(dependencyAbsolutePath, 'index.js');\n    if (index === toFileAbsolutePath) {\n      return true;\n    } else {\n      dependencyAbsolutePath += path.extname(to);\n    }\n  }\n  return dependencyAbsolutePath === toFileAbsolutePath;\n}\n\n// Implementation of floydWarshall alg for calculating visibility matrix in O(n^3) instead of O(n^4) with successive raising of powers\n\nfunction createVisibilityMatrix(result) {\n  var changeCost = 0;\n  var distMatrix = adjacencyToDistMatrix(result.adjacencyMatrix);\n  var matrixLen = distMatrix.length;\n  for (var k = 0; k < matrixLen; k += 1) {\n    for (var i = 0; i < matrixLen; i += 1) {\n      for (var j = 0; j < matrixLen; j += 1) {\n        if (distMatrix[i][j] > distMatrix[i][k] + distMatrix[k][j]) {\n          distMatrix[i][j] = distMatrix[i][k] + distMatrix[k][j];\n        }\n      }\n    }\n  }\n\n  // Convert back from a distance matrix to adjacency matrix, while also calculating change cost\n  var visibilityMatrix = distMatrix.map(function (row, rowIndex) {\n    return row.map(function (value, columnIndex) {\n      if (value < Infinity) {\n        changeCost += 1;\n        if (columnIndex !== rowIndex) {\n          return 1;\n        }\n      }\n      return 0;\n    });\n  });\n  result.visibilityMatrix = visibilityMatrix;\n  result.changeCost = percentifyDensity(changeCost, visibilityMatrix);\n}\n\nfunction adjacencyToDistMatrix(matrix) {\n  var distMatrix = [];\n  for (var i = 0; i < matrix.length; i += 1) {\n    distMatrix.push([]);\n    for (var j = 0; j < matrix[i].length; j += 1) {\n      var value = null;\n      if (i === j) {\n        value = 1;\n      } else {\n        // Where we have 0, set distance to Infinity\n        value = matrix[i][j] || Infinity;\n      }\n      distMatrix[i][j] = value;\n    }\n  }\n  return distMatrix;\n}\n\nfunction setCoreSize(result) {\n  if (result.firstOrderDensity === 0) {\n    result.coreSize = 0;\n    return;\n  }\n  var fanIn = new Array(result.visibilityMatrix.length);\n  var fanOut = new Array(result.visibilityMatrix.length);\n  var boundaries = {};\n  var coreSize = 0;\n  result.visibilityMatrix.forEach(function (row, rowIndex) {\n    fanIn[rowIndex] = row.reduce(function (sum, value, valueIndex) {\n      if (rowIndex === 0) {\n        fanOut[valueIndex] = value;\n      } else {\n        fanOut[valueIndex] += value;\n      }\n      return sum + value;\n    }, 0);\n  });\n\n  // Boundary values can also be chosen by looking for discontinuity in the\n  // Distribution of values, but I've chosen the median to keep it simple.\n  boundaries.fanIn = getMedian(fanIn.slice());\n  boundaries.fanOut = getMedian(fanOut.slice());\n  result.visibilityMatrix.forEach(function (ignore, index) {\n    if (fanIn[index] >= boundaries.fanIn && fanOut[index] >= boundaries.fanOut) {\n      coreSize += 1;\n    }\n  });\n  result.coreSize = percentify(coreSize, result.visibilityMatrix.length);\n}\n\nfunction getMedian(values) {\n  values.sort(compareNumbers);\n  if (values.length % 2 === 1) {\n    return values[(values.length - 1) / 2];\n  }\n  return (values[(values.length - 2) / 2] + values[values.length / 2]) / 2;\n}\n\nfunction compareNumbers(lhs, rhs) {\n  if (lhs < rhs) {\n    return -1;\n  }\n  if (lhs > rhs) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction calculateAverages(result) {\n  var divisor;\n  var sums = {\n    cyclomatic: 0,\n    effort: 0,\n    loc: 0,\n    maintainability: 0,\n    params: 0\n  };\n  if (result.reports.length === 0) {\n    divisor = 1;\n  } else {\n    divisor = result.reports.length;\n  }\n  result.reports.forEach(function (report) {\n    return Object.keys(sums).forEach(function (key) {\n      sums[key] += report[key];\n    });\n  });\n  Object.keys(sums).forEach(function (key) {\n    result[key] = sums[key] / divisor;\n  });\n}\n"},"repo0src/safeArray_js":{"id":"repo0src/safeArray_js","name":"safeArray.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/safeArray.js","code":"'use strict';\n\nmodule.exports = function (thing) {\n  if (typeof thing === 'undefined') {\n    return [];\n  }\n  if (Array.isArray(thing)) {\n    return thing;\n  }\n  return [thing];\n};\n"},"repo0src/safeName_js":{"id":"repo0src/safeName_js","name":"safeName.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/safeName.js","code":"'use strict';\n\nconst _isObject = require('lodash.isobject');\nconst _isString = require('lodash.isstring');\n\nmodule.exports = function(object, defaultName) {\n  if ( _isObject(object) && _isString(object.name) && object.name.length > 0) {\n    return object.name;\n  }\n\n  if ( _isString(defaultName) && defaultName.length > 0 ) {\n    return defaultName;\n  }\n\n  return '<anonymous>';\n};\n"},"repo0src/walker_js":{"id":"repo0src/walker_js","name":"walker.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/walker.js","code":"'use strict'\n\nconst _isObject = require('lodash.isobject')\nconst _isFunction = require('lodash.isfunction')\nconst assert = require('assert')\nconst safeName = require('./safeName')\nconst syntaxDefinitions = require('./syntax')\nconst debug = require('debug')('escomplex:walker')\n\nmodule.exports.walk = walk\n\n// Settings\n// - trycatch (Boolean)\n// - forin (Boolean)\n// - logicalor (Boolean)\n// - switchcase (Boolean)\n//\n\nfunction walk (tree, settings, callbacks) {\n  assert(_isObject(tree), 'Invalid syntax tree')\n  assert(Array.isArray(tree.body), 'Invalid syntax tree body')\n  assert(_isObject(settings), 'Invalid settings')\n  assert(_isObject(callbacks), 'Invalid callbacks')\n  assert(_isFunction(callbacks.processNode), 'Invalid processNode callback')\n  assert(_isFunction(callbacks.createScope), 'Invalid createScope callback')\n  assert(_isFunction(callbacks.popScope), 'Invalid popScope callback')\n\n  visitNodes(tree.body)\n\n  function getSyntax (type) {\n    const definition = syntaxDefinitions[type]\n\n    if (_isFunction(definition)) {\n      return definition(settings)\n    }\n  }\n\n  function visitNodes (nodes, assignedName) {\n    nodes.forEach(function(node){return  visitNode(node, assignedName);})\n  }\n\n  function visitNode (node, assignedName) {\n    if (_isObject(node)) {\n      debug('node type: ' + node.type)\n      const syntax = getSyntax(node.type)\n      debug('syntax: ' + JSON.stringify(syntax))\n      if (_isObject(syntax)) {\n        callbacks.processNode(node, syntax)\n        if (syntax.newScope) {\n          callbacks.createScope(safeName(node.id, assignedName), node.loc, node.params.length)\n        }\n        visitChildren(node)\n        if (syntax.newScope) {\n          callbacks.popScope()\n        }\n      }\n    }\n  }\n\n  function visitChildren (node) {\n    const syntax = getSyntax(node.type)\n    if (Array.isArray(syntax.children)) {\n      syntax.children.forEach(function(child){return visitChild(\n        node[child],\n        _isFunction(syntax.assignableName) ? syntax.assignableName(node) : ''\n      );})\n    }\n  }\n\n  function visitChild (child, assignedName) {\n    const visitor = Array.isArray(child) ? visitNodes : visitNode\n    visitor(child, assignedName)\n  }\n}\n"},"repo0src/metrics":{"id":"repo0src/metrics","name":"metrics","enabled":true,"hovered":false,"repoid":"repo0","path":"src/metrics"},"repo0src/metrics/halstead_js":{"id":"repo0src/metrics/halstead_js","name":"halstead.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/metrics/halstead.js","code":"'use strict'\n\nmodule.exports = HalsteadMetrics\n\nfunction HalsteadMetrics () {\n  this.operands = {\n    distinct: 0,\n    identifiers: [],\n    total: 0\n  }\n  this.operators = {\n    distinct: 0,\n    identifiers: [],\n    total: 0\n  }\n  this.reset()\n}\n\nHalsteadMetrics.prototype.reset = function () {\n  this.vocabulary = 0\n  this.difficulty = 0\n  this.volume = 0\n  this.effort = 0\n  this.bugs = 0\n  this.time = 0\n}\n\nHalsteadMetrics.prototype.calculate = function () {\n  this.length = this.operators.total + this.operands.total\n  if (this.length === 0) {\n    this.reset()\n  } else {\n    this.vocabulary = this.operators.distinct + this.operands.distinct\n    this.difficulty = (this.operators.distinct / 2) * (this.operands.distinct === 0 ? 1 : this.operands.total / this.operands.distinct)\n    this.volume = this.length * (Math.log(this.vocabulary) / Math.log(2))\n    this.effort = this.difficulty * this.volume\n    this.bugs = this.volume / 3000\n    this.time = this.effort / 18\n  }\n}\n"},"repo0src/syntax":{"id":"repo0src/syntax","name":"syntax","enabled":true,"hovered":false,"repoid":"repo0","path":"src/syntax"},"repo0src/syntax/es5_js":{"id":"repo0src/syntax/es5_js","name":"es5.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/syntax/es5.js","code":"'use strict';\n\nvar _merge = require('lodash.merge');\nvar _isString = require('lodash.isstring');\nvar safeName = require('../safeName');\nvar safeArray = require('../safeArray');\n\nvar DEFAULTS = {\n  assignableName: undefined,\n  children: safeArray(undefined),\n  cyclomatic: 0,\n  lloc: 0,\n  newScope: undefined,\n  dependencies: undefined\n};\n\nvar operators = function operators(properties) {\n  return properties.map(function (property) {\n    if (property && typeof property.identifier !== 'undefined') {\n      return property;\n    }\n    return {\n      identifier: property\n    };\n  });\n};\n\nvar operands = function operands(identifiers) {\n  return identifiers.map(function (identifier) {\n    return { identifier: identifier };\n  });\n};\n\nfunction defineSyntax(spec) {\n  var computedSpec = {\n    children: safeArray(spec.children),\n    operands: operands(safeArray(spec.operands)),\n    operators: operators(safeArray(spec.operators))\n  };\n  return _merge({}, DEFAULTS, spec, computedSpec);\n}\n\nvar ArrayExpression = function ArrayExpression(settings) {\n  return defineSyntax({\n    operators: '[]',\n    operands: safeName,\n    children: 'elements'\n  });\n};\n\nvar AssignmentExpression = function AssignmentExpression(settings) {\n  return defineSyntax({\n    operators: function operators(node) {\n      return node.operator;\n    },\n    children: ['left', 'right'],\n    assignableName: function assignableName(node) {\n      if (node.left.type === 'MemberExpression') {\n        return safeName(node.left.object) + '.' + node.left.property.name;\n      }\n      return safeName(node.left.id);\n    }\n  });\n};\n\nvar BinaryExpression = function BinaryExpression(settings) {\n  return defineSyntax({\n    operators: function operators(node) {\n      return node.operator;\n    },\n    children: ['left', 'right']\n  });\n};\n\nvar BlockStatement = function BlockStatement(settings) {\n  return defineSyntax({\n    children: 'body'\n  });\n};\n\nvar BreakStatement = function BreakStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'break',\n    children: ['label']\n  });\n};\n\nvar amdPathAliases = {};\n\nfunction dependencyPath(item, fallback) {\n  if (item.type === 'Literal') {\n    return amdPathAliases[item.value] || item.value;\n  }\n  return fallback;\n}\n\nfunction processRequire(node) {\n  var line = node.loc.start.line;\n  var path = '* dynamic dependency *';\n  var args = node.arguments;\n\n  if (args.length === 1) {\n    return {\n      line: line,\n      type: 'CommonJS',\n      path: dependencyPath(args[0], path)\n    };\n  }\n\n  if (args.length === 2) {\n    var type = 'AMD';\n\n    if (args[0].type === 'ArrayExpression') {\n      return args[0].elements.map(function (item) {\n        return {\n          type: type,\n          line: line,\n          path: dependencyPath(item, path)\n        };\n      });\n    }\n\n    return {\n      type: type,\n      line: line,\n      path: dependencyPath(args[0], '* dynamic dependencies *')\n    };\n  }\n}\n\nvar CallExpression = function CallExpression(settings) {\n  return defineSyntax({\n    lloc: function lloc(node) {\n      return node.callee.type === 'FunctionExpression' ? 1 : 0;\n    },\n    operators: '()',\n    children: ['arguments', 'callee'],\n    dependencies: function dependencies(node, clearAliases) {\n      if (clearAliases) {\n        // TODO: This prohibits async running. Refine by passing in module id as key for amdPathAliases.\n        amdPathAliases = {};\n      }\n\n      if (node.callee.type === 'Identifier' && node.callee.name === 'require') {\n        return processRequire(node);\n      }\n\n      if (node.callee.type === 'MemberExpression' && node.callee.object.type === 'Identifier' && node.callee.object.name === 'require' && node.callee.property.type === 'Identifier' && node.callee.property.name === 'config') {\n        var args = node.arguments;\n        if (args.length === 1 && args[0].type === 'ObjectExpression') {\n          args[0].properties.forEach(function (property) {\n            if (property.key.type === 'Identifier' && property.key.name === 'paths' && property.value.type === 'ObjectExpression') {\n              property.value.properties.forEach(function (alias) {\n                if (alias.key.type === 'Identifier' && alias.value.type === 'Literal') {\n                  amdPathAliases[alias.key.name] = alias.value.value;\n                }\n              });\n            }\n          });\n        }\n      }\n    }\n  });\n};\n\nvar CatchClause = function CatchClause(settings) {\n  return defineSyntax({\n    lloc: 1,\n    cyclomatic: settings.trycatch ? 1 : 0,\n    operators: 'catch',\n    children: ['param', 'body']\n  });\n};\n\nvar ConditionalExpression = function ConditionalExpression(settings) {\n  return defineSyntax({\n    cyclomatic: 1,\n    operators: ':?',\n    children: ['test', 'consequent', 'alternate']\n  });\n};\n\nvar ContinueStatement = function ContinueStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'continue',\n    children: ['label']\n  });\n};\n\nvar DebuggerStatement = function DebuggerStatement(settings) {\n  return defineSyntax({});\n};\n\nvar DoWhileStatement = function DoWhileStatement(settings) {\n  return defineSyntax({\n    lloc: 2,\n    cyclomatic: function cyclomatic(node) {\n      return node.test ? 1 : 0;\n    },\n    operators: 'dowhile',\n    children: ['test', 'body']\n  });\n};\n\nvar EmptyStatement = function EmptyStatement(settings) {\n  return defineSyntax({});\n};\n\nvar ExpressionStatement = function ExpressionStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    children: ['expression']\n  });\n};\n\nvar ForInStatement = function ForInStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    cyclomatic: settings.forin ? 1 : 0,\n    operators: 'forin',\n    children: ['left', 'right', 'body']\n  });\n};\n\nvar ForStatement = function ForStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    cyclomatic: function cyclomatic(node) {\n      return node.test ? 1 : 0;\n    },\n    operators: 'for',\n    children: ['init', 'test', 'update', 'body']\n  });\n};\n\nvar FunctionDeclaration = function FunctionDeclaration(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'function',\n    operands: function operands(node) {\n      return safeName(node.id);\n    },\n    children: ['params', 'body'],\n    newScope: true\n  });\n};\n\nvar FunctionExpression = function FunctionExpression(settings) {\n  return defineSyntax({\n    operators: 'function',\n    operands: function operands(node) {\n      return safeName(node.id);\n    },\n    children: ['params', 'body'],\n    newScope: true\n  });\n};\n\nvar Identifier = function Identifier(settings) {\n  return defineSyntax({\n    operands: function operands(node) {\n      return node.name;\n    }\n  });\n};\n\nvar IfStatement = function IfStatement(settings) {\n  return defineSyntax({\n    lloc: function lloc(node) {\n      return node.alternate ? 2 : 1;\n    },\n    cyclomatic: 1,\n    operators: ['if', {\n      filter: function filter(node) {\n        return !!node.alternate;\n      },\n      identifier: 'else'\n    }],\n    children: ['test', 'consequent', 'alternate']\n  });\n};\n\nvar LabeledStatement = function LabeledStatement(settings) {\n  return defineSyntax({});\n};\n\nvar Literal = function Literal(settings) {\n  return defineSyntax({\n    operands: function operands(node) {\n      if (_isString(node.value)) {\n        return '\"' + node.value + '\"';\n      }\n      return node.value;\n    }\n  });\n};\n\nvar LogicalExpression = function LogicalExpression(settings) {\n  return defineSyntax({\n    cyclomatic: function cyclomatic(node) {\n      var isAnd = node.operator === '&&';\n      var isOr = node.operator === '||';\n      return isAnd || settings.logicalor && isOr ? 1 : 0;\n    },\n    operators: function operators(node) {\n      return node.operator;\n    },\n    children: ['left', 'right']\n  });\n};\n\nvar MemberExpression = function MemberExpression(settings) {\n  return defineSyntax({\n    lloc: function lloc(node) {\n      var type = node.object.type;\n      if (type === 'ObjectExpression' || type === 'ArrayExpression' || type === 'FunctionExpression') {\n        return 1;\n      }\n      return 0;\n    },\n    operators: '.',\n    children: ['object', 'property']\n  });\n};\n\nvar NewExpression = function NewExpression(settings) {\n  return defineSyntax({\n    lloc: function lloc(node) {\n      return node.callee.type === 'FunctionExpression' ? 1 : 0;\n    },\n    operators: 'new',\n    children: ['arguments', 'callee']\n  });\n};\n\nvar ObjectExpression = function ObjectExpression(settings) {\n  return defineSyntax({\n    operators: '{}',\n    operands: safeName,\n    children: 'properties'\n  });\n};\n\nvar Property = function Property(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: ':',\n    children: ['key', 'value'],\n    assignableName: function assignableName(node) {\n      return safeName(node.key);\n    }\n  });\n};\n\nvar ReturnStatement = function ReturnStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'return',\n    children: 'argument'\n  });\n};\n\nvar SequenceExpression = function SequenceExpression(settings) {\n  return defineSyntax({ children: 'expressions' });\n};\n\nvar SwitchCase = function SwitchCase(settings) {\n  return defineSyntax({\n    lloc: 1,\n    cyclomatic: function cyclomatic(node) {\n      return settings.switchcase && node.test ? 1 : 0;\n    },\n    operators: function operators(node) {\n      return node.test ? 'case' : 'default';\n    },\n    children: ['test', 'consequent']\n  });\n};\n\nvar SwitchStatement = function SwitchStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'switch',\n    children: ['discriminant', 'cases']\n  });\n};\n\nvar ThisExpression = function ThisExpression(settings) {\n  return defineSyntax({ operands: 'this' });\n};\nvar ThrowStatement = function ThrowStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'throw',\n    children: 'argument'\n  });\n};\n\nvar TryStatement = function TryStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    children: ['block', 'handler']\n  });\n};\n\nvar UnaryExpression = function UnaryExpression(settings) {\n  return defineSyntax({\n    operators: function operators(node) {\n      return node.operator + ' (' + (node.prefix ? 'pre' : 'post') + 'fix)';\n    },\n    children: 'argument'\n  });\n};\n\nvar UpdateExpression = function UpdateExpression(settings) {\n  return defineSyntax({\n    operators: function operators(node) {\n      return node.operator + ' (' + (node.prefix ? 'pre' : 'post') + 'fix)';\n    },\n    children: 'argument'\n  });\n};\n\nvar VariableDeclaration = function VariableDeclaration(settings) {\n  return defineSyntax({\n    operators: function operators(node) {\n      return node.kind;\n    },\n    children: 'declarations'\n  });\n};\n\nvar VariableDeclarator = function VariableDeclarator(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: {\n      filter: function filter(node) {\n        return !!node.init;\n      },\n      identifier: '='\n    },\n    children: ['id', 'init'],\n    assignableName: function assignableName(node) {\n      return safeName(node.id);\n    }\n  });\n};\n\nvar WhileStatement = function WhileStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    cyclomatic: function cyclomatic(node) {\n      return node.test ? 1 : 0;\n    },\n    operators: 'while',\n    children: ['test', 'body']\n  });\n};\n\nvar WithStatement = function WithStatement(settings) {\n  return defineSyntax({\n    lloc: 1,\n    operators: 'with',\n    children: ['object', 'body']\n  });\n};\n\nmodule.exports = {\n  ArrayExpression: ArrayExpression,\n  AssignmentExpression: AssignmentExpression,\n  BinaryExpression: BinaryExpression,\n  BlockStatement: BlockStatement,\n  BreakStatement: BreakStatement,\n  CallExpression: CallExpression,\n  CatchClause: CatchClause,\n  ConditionalExpression: ConditionalExpression,\n  ContinueStatement: ContinueStatement,\n  DebuggerStatement: DebuggerStatement,\n  DoWhileStatement: DoWhileStatement,\n  EmptyStatement: EmptyStatement,\n  ExpressionStatement: ExpressionStatement,\n  ForInStatement: ForInStatement,\n  ForStatement: ForStatement,\n  FunctionDeclaration: FunctionDeclaration,\n  FunctionExpression: FunctionExpression,\n  Identifier: Identifier,\n  IfStatement: IfStatement,\n  LabeledStatement: LabeledStatement,\n  Literal: Literal,\n  LogicalExpression: LogicalExpression,\n  MemberExpression: MemberExpression,\n  NewExpression: NewExpression,\n  ObjectExpression: ObjectExpression,\n  Property: Property,\n  ReturnStatement: ReturnStatement,\n  SequenceExpression: SequenceExpression,\n  SwitchCase: SwitchCase,\n  SwitchStatement: SwitchStatement,\n  ThisExpression: ThisExpression,\n  ThrowStatement: ThrowStatement,\n  TryStatement: TryStatement,\n  UnaryExpression: UnaryExpression,\n  UpdateExpression: UpdateExpression,\n  VariableDeclaration: VariableDeclaration,\n  VariableDeclarator: VariableDeclarator,\n  WhileStatement: WhileStatement,\n  WithStatement: WithStatement\n};\n"},"repo0src/syntax/index_js":{"id":"repo0src/syntax/index_js","name":"index.js","enabled":true,"hovered":false,"repoid":"repo0","path":"src/syntax/index.js","code":"'use strict'\n\nconst _merge = require('lodash.merge')\n\nmodule.exports = _merge(\n  {},\n  require('./es5')\n)\n"}},"repoNodeOutEdges":{"repo0_root":{"id":"repo0_root","repoid":"repo0","edges":["repo0src/config_js","repo0src/core_js","repo0src/index_js","repo0src/metrics","repo0src/module_js","repo0src/project_js","repo0src/safeArray_js","repo0src/safeName_js","repo0src/syntax","repo0src/walker_js"]},"repo0src/metrics":{"id":"repo0src/metrics","repoid":"repo0","edges":["repo0src/metrics/halstead_js"]},"repo0src/syntax":{"id":"repo0src/syntax","repoid":"repo0","edges":["repo0src/syntax/es5_js","repo0src/syntax/index_js"]}},"helpMessages":{},"analysisMods":{"repo0":{"id":"repo0","devcost":"80","changetime":"60"}}};
